<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Artificial Intelligence Survey &#8211; Yağız Aksoy</title>
<meta name="description" content="PhD">




<!-- Twitter Cards -->
<meta name="twitter:title" content="Artificial Intelligence Survey">
<meta name="twitter:description" content="PhD">
<meta name="twitter:site" content="@yagizaksoy">
<meta name="twitter:creator" content="@yagizaksoy">

<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yaksoy.github.io/images/jorge.png">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Artificial Intelligence Survey">
<meta property="og:description" content="PhD">
<meta property="og:url" content="http://yaksoy.github.io/ais/pa1/">
<meta property="og:site_name" content="Yağız Aksoy">

<!-- Webmaster Tools verfication -->
<meta name="google-site-verification" content="googleb0479c04a25255c3">



<link rel="canonical" href="http://yaksoy.github.io/ais/pa1/">
<link href="http://yaksoy.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="Yağız Aksoy Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://yaksoy.github.io/assets/css/main.css">
<!-- Webfonts -->
<script src="//use.edgefonts.net/source-sans-pro:n2,i2,n3,i3,n4,i4,n6,i6,n7,i7,n9,i9;source-code-pro:n4,n7;volkhov.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
  <script src="http://yaksoy.github.io/assets/js/vendor/html5shiv.min.js"></script>
  <script src="http://yaksoy.github.io/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- Modernizr -->
<script src="http://yaksoy.github.io/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://yaksoy.github.io/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://yaksoy.github.io/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://yaksoy.github.io/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://yaksoy.github.io/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://yaksoy.github.io/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://yaksoy.github.io/images/apple-touch-icon-144x144-precomposed.png">

</head>

<body id="page">

<div id="main" role="main">
  <article class="entry">
    <div class="entry-wrapper">
      <br><br>
      <!-- <header class="entry-header">-->
        <h1 class="entry-titleProject" style="margin-top:5px;">Artificial Intelligence Survey</h1>
      <!-- </header>-->
      <div class="entry-titleAuthors">
        Programming Assignment 1
      </div>
      <div class="entry-titleVenue">
        
      </div>
    </div><!-- /.entry-wrapper -->
    
    <div class="entry-wrapper">
      <div class="entry-contentProject">
        <div class="wikicontents markdown tex2jax_ignore">
    <p>In this assignment, your Pac-Man agent will find paths through his maze world,
    both to reach a particular location and to collect food efficiently. You will build
    general search algorithms and apply them to Pac-Man scenarios.</p>

    <p>The code for this project consists of several Python files, some of which you will
    need to read and understand in order to complete the assignment, and some of which
    you can ignore. <b>You can download all the code as a zip <a href="./A1.zip">&lt;&lt;&lt;<u>here</u>&gt;&gt;&gt;</a>.</b>

    <p><strong>Files you'll edit</strong>:</p>

    <p><strong>For Q1.1, Q1.2, and Q1.3:</strong></p>
    <pre>
search.py          Where all of your search algorithms will reside.
</pre>

    <p><strong>For Q2.1 and Q2.2:</strong></p>
    <pre>
searchAgents.py  Where all of your search-based agents will reside.
</pre>

    <p><strong>Files you might want to look at:</strong></p>
    <pre>
pacman.py       The main file that runs Pac-Man games.
 This file describes a Pac-Man GameState type, which you use in this project.
game.py    The logic behind how the Pac-Man world works.
 This file describes several supporting types like AgentState, Agent, Direction, and Grid.
util.py     Useful data structures for implementing search algorithms.
</pre>

    <p><strong>Supporting files you can ignore:</strong></p>
    <pre>
graphicsDisplay.py      Graphics for Pac-Man
graphicsUtils.py        Support for Pac-Man graphics
textDisplay.py      ASCII graphics for Pac-Man
ghostAgents.py     Agents to control ghosts
keyboardAgents.py       Keyboard interfaces to control Pac-Man
layout.py        Code for reading layout files and storing their contents
</pre>

    <p><strong>What to submit</strong>: You will fill in portions of search.py and
    searchAgents.py during the assignment. You should submit these two files (only) to
    <a href="https://coursys.sfu.ca/2020sp-cmpt-310-d1/">CourSYS</a>.</p>

    <p><strong>Evaluation</strong>: Your code will be <em>partially autograded</em> for technical
    correctness. Please do not change the names of any provided functions or classes
    within the code, or you will wreak havoc on the autograder. However, the correctness
    of your implementation -- not the autograder's output -- will be the final judge of
    your score. If necessary, we will review and grade assignments individually to ensure
    that you receive due credit for your work.</p>

    <p>We have included an autograder for you to grade your answers on your machine. Note that it will 
        <em>not</em> grade Question 1.4. The autograder can be run with the command:
    </p>
    <pre lang="python" xml:lang="python">
<code>python autograder.py
</code>
</pre>

    <p><strong>Academic Dishonesty</strong>: We will be checking your code against other
    submissions in the class for logical redundancy. We trust you all to submit your own
    work only; please don't let us down. If you do, we will pursue the strongest
    consequences available to us.</p>

    <p><strong>Getting Help</strong>: You are not alone! If you find yourself stuck on
    something, contact the TAs for help. The TAs will have additional office hours before
    the assignment is due. Alternatively, you can post your questions to Piazza.</p>

    <p>We want these projects to be rewarding and instructional, not frustrating and
    demoralizing. But, we don't know when or how to help unless you ask.</p>

    <p><strong>One more piece of advice</strong>: if you don't know what a variable does
    or what kind of values it takes, print it out.</p>

    <h3>Part 0 Welcome to Pac-Man</h3>

    <p>After downloading the code (<a href="./A1.zip">A1.zip</a>), unzipping
    it and changing the current working directory to the A1 directory, you should be able
    to play a game of Pac-Man by typing the following at the command line:</p>
    <pre lang="python" xml:lang="python">
<code>python pacman.py
</code>
</pre>

    <p><strong>Note</strong>: Make sure you are running a recent version of Python (3.6
    or later). Depend on your system configuration, You may need to use python3 instead
    of python to run this program.</p>

    <p>Pac-Man lives in a shiny blue world of twisting corridors and tasty round treats.
    Navigating this world efficiently will be Pac-Man's first step in mastering his
    domain. The simplest agent in searchAgents.py is called the <em>GoWestAgent</em>,
    which always goes West (a trivial reflex agent). This agent can occasionally win:</p>
    <pre lang="python" xml:lang="python">
<code>python pacman.py --layout testMaze --pacman GoWestAgent
</code>
</pre>

    <p>But, things get ugly for this agent when turning is required:</p>
    <pre lang="python" xml:lang="python">
<code>python pacman.py --layout tinyMaze --pacman GoWestAgent
</code>
</pre>

    <p>If pacman gets stuck, you can exit the game by typing CTRL-c into your terminal.
    Soon, your agent will solve not only tinyMaze, but any maze you want. Note that
    pacman.py supports a number of options that can each be expressed in a long way
    (e.g., --layout) or a short way (e.g., -l). You can see the list of all options and
    their default values via:</p>
    <pre lang="python" xml:lang="python">
<code>python pacman.py -h
</code>
</pre>

    <h3>Part 1 Finding a Fixed Food Dot using Search Algorithms</h3>

    <p>In searchAgents.py, you'll find a fully implemented <em>SearchAgent</em>, which
    plans out a path through Pac-Man's world and then executes that path step-by-step.
    The search algorithms for formulating a plan are not implemented -- that's your job.
    First, test that the <em>SearchAgent</em> is working correctly by running:</p>
    <pre lang="python" xml:lang="python">
<code>python pacman.py -l tinyMaze -p SearchAgent -a fn=tinyMazeSearch
</code>
</pre>

    <p>The command above tells the <em>SearchAgent</em> to use <em>tinyMazeSearch</em> as
    its search algorithm, which is implemented in search.py. Pac-Man should navigate the
    maze successfully.</p>

    <p>Now it's time to write full-fledged generic search functions to help Pac-Man plan
    routes! Pseudocode for the search algorithms you'll write can be found in the lecture
    slides and textbook. Remember that a search node must contain not only a state but
    also the information necessary to reconstruct the path (plan) which gets to that
    state.</p>

    <p><strong>Important note</strong>: All of your search functions need to return a
    <strong>list</strong> of actions that will lead the agent from the start to the goal.
    These actions all have to be legal moves (valid directions, no moving through
    walls).</p>

    <p>Hint: Make sure to check out the <em>Stack</em>, <em>Queue</em> and
    <em>PriorityQueue</em> types provided to you in util.py!</p>

    <h4>Question 1.1 (2 points)</h4>

    <p>Implement the depth-first search (DFS) algorithm in the <em>depthFirstSearch</em>
    function in search.py . To make your algorithm complete, write the graph search
    version of DFS, which avoids expanding any already visited states (R&amp;N 3ed
    Section 3.3, Figure 3.7). Use an appropriate data structure for storing the fringe for 
    DFS. Your code should quickly find a solution for:</p>
    <pre lang="python" xml:lang="python">
<code>python pacman.py -l tinyMaze -p SearchAgent
python pacman.py -l mediumMaze -p SearchAgent
python pacman.py -l bigMaze -z .5 -p SearchAgent
</code>
</pre>

    <p>The Pac-Man board will show an overlay of the states explored, and the order in
    which they were explored (brighter red means earlier exploration). Is the exploration
    order what you would have expected? Does Pac-Man actually go to all the explored
    squares on his way to the goal?</p>

    <p>Hint: If you use a Stack as your data structure, the solution found by your DFS
    algorithm for mediumMazeshould have a length of 130 (provided you push successors
    onto the fringe in the order provided by getSuccessors; you might get 244 if you push
    them in the reverse order). Is this a least cost solution? If not, think about what
    depth-first search is doing wrong.</p>

    <h4>Question 1.2 (2 points)</h4>

    <p>Implement the breadth-first search (BFS) algorithm in the
    <em>breadthFirstSearch</em> function in search.py . Again, write a graph search
    algorithm that avoids expanding any already visited states. Use an appropriate data 
    structure for storing the fringe for BFS. Test your code the same
    way you did for depth-first search.</p>
    <pre lang="python" xml:lang="python">
<code>python pacman.py -l mediumMaze -p SearchAgent -a fn=bfs
python pacman.py -l bigMaze -p SearchAgent -a fn=bfs -z .5
</code>
</pre>

    <p>Does BFS find a least cost solution? If not, check your implementation.</p>

    <p>Hint: If Pac-Man moves too slowly for you, try the option --frameTime 0.</p>

    <p>Note: If you've written your search code generically, your code should work
    equally well for the eight-puzzle search problem (R&amp;N 3ed Section 3.2, Figure
    3.4) without any changes.</p>
    <pre lang="python" xml:lang="python">
<code>python eightpuzzle.py
</code>
</pre>

    <h4>Question 1.3 (3 points)</h4>

    <p>Implement A* graph search in the empty function <em>aStarSearch</em> in search.py
    . A* takes a heuristic function as an argument. Heuristics take two arguments: a
    state in the search problem (the main argument), and the problem itself (for
    reference information). The <em>nullHeuristic</em> heuristic function in search.py is
    a trivial example. You can test your A* implementation on the original problem of
    finding a path through a maze to a fixed position using the Manhattan distance
    heuristic (implemented already as <em>manhattanHeuristic</em> in searchAgents.py
    ).</p>
    <pre lang="python" xml:lang="python">
        <code>python pacman.py -l bigMaze -z .5 -p SearchAgent -a fn=astar,heuristic=manhattanHeuristic</code>
    </pre>

    <h4>Question 1.4 (1 point) </h4>
    <p>
        In Question 1.1 and 1.2 you implemented BFS and DFS using well-fitting data structures for each. It is possible to 
        implement these algorithms by using a priority queue, as you did in A*. Please implement BFS and DFS again using a 
        priority queue, and compare the performance with your original implementations. Draw a conclusion about whether 
        this is a good implementation strategy for BFS and DFS and include your discussions as comments in your search.py file.
    </p>

    <p>
        Note: This question is not included in the autograder.
    </p>

    <p>
        Test your code analogously as to in Q1.1 and Q1.2, namely:
    </p>
    
    <pre lang="python" xml:lang="python">
        <code>
            python pacman.py -l mediumMaze -p SearchAgent -a fn=bfs2
            python pacman.py -l bigMaze -p SearchAgent -a fn=bfs2 -z .5

            python pacman.py -l mediumMaze -p SearchAgent -a fn=dfs2
            python pacman.py -l bigMaze -p SearchAgent -a fn=dfs2 -z .5
        </code>
    </pre>

    <p>
        Hint: It is possible to implement both of these algorithms by using a generic best-first search algorithm, and accepting as a parameter a function which determines how priorities are assigned. You are not required to implement these algorithms using this technique, however it may help you to reduce the amount of code you have to write on this assignment.
    </p>
    

    <h3>Part 2 Finding All the Corners</h3>

    <p>The real power of A* will only be apparent with a more challenging search problem.
    Now, it's time to formulate a new problem and design a heuristic for it.</p>

    <p>In corner mazes, there are four dots, one in each corner. Our new search problem
    is to find the shortest path through the maze that touches all four corners (whether
    the maze actually has food there or not). Note that for some mazes like
    <em>tinyCorners</em>, the shortest path does not always go to the closest food
    first!</p>

    <p>Hint: the shortest path through <em>tinyCorners</em> takes 28 steps.</p>

    <h4>Question 2.1 (4 points)</h4>

    <p>Implement the <em>CornersProblem</em> search problem in searchAgents.py. That is,
    complete the missing part in the class <em>CornersProblem</em> to correctly represent
    the problem. You will need to choose a state representation that encodes all the
    information necessary to detect whether all four corners have been reached. Now, your
    search agent should solve:</p>
    <pre lang="python" xml:lang="python">
<code>python pacman.py -l tinyCorners -p SearchAgent -a fn=bfs,prob=CornersProblem
python pacman.py -l mediumCorners -p SearchAgent -a fn=bfs,prob=CornersProblem
</code>
</pre>

    <p>To receive full credit, you need to define an abstract state representation that
    does not encode irrelevant information (like the position of ghosts, where extra food
    is, etc.). In particular, do not use a Pac-Man GameState as a search state. Your code
    will be very, very slow if you do (and also wrong).</p>

    <p>Hint: The only parts of the game state you need to reference in your
    implementation are the starting Pac-Man position and the location of the four
    corners.</p>

    <p>Our implementation of <em>breadthFirstSearch</em> expands just under 2000 search
    nodes on <em>mediumCorners</em>. However, heuristics (used with A* search) can reduce
    the amount of searching required.</p>

    <h4>Question 2.2 (4 points)</h4>

    <p>Implement a heuristic for the CornersProblem in <em>cornersHeuristic</em>.</p>

    <p>Grading: inadmissible heuristics will get no credit. 1 point for any admissible
    heuristic. 1 point for expanding fewer than 1600 nodes. 1 point for expanding fewer
    than 1200 nodes. Expand fewer than 800, and you're doing great!</p>
    <pre lang="python" xml:lang="python">
<code>python pacman.py -l mediumCorners -p SearchAgent -a fn=aStarSearch,prob=CornersProblem,heuristic=cornersHeuristic -z 0.5
</code>
</pre>

    <p><strong>Admissibility vs. Consistency</strong>: Remember, heuristics are just
    functions that take search states and return numbers that estimate the cost to the
    nearest goal. More effective heuristics will return values closer to the actual goal
    costs. To be admissible, the heuristic values must be lower bounds on the actual
    shortest path cost to the nearest goal (and non-negative). To be consistent, it must
    additionally hold that if an action has cost c, then taking that action can only
    cause a drop in heuristic of at most c.</p>

    <p>Remember that admissibility isn't enough to guarantee correctness in graph search
    -- you need the stronger condition of consistency. However, admissible heuristics are
    usually also consistent, especially if they are derived from problem relaxations.
    Therefore it is usually easiest to start out by brainstorming admissible heuristics.
    Once you have an admissible heuristic that works well, you can check whether it is
    indeed consistent, too. The only way to guarantee consistency is with a proof.
    However, inconsistency can often be detected by verifying that for each node you
    expand, its successor nodes are equal or higher in f-value. Moreover, if BFS and A*
    ever return paths of different lengths, your heuristic is inconsistent. This stuff is
    tricky!</p>

    <p><strong>Complexity</strong>: heuristic must be sub-exponential in the size of the
    maze. Most reasonable heuristics are O(1) in the size of the maze. For example, a
    constant number of Manhattan distance calculation is O(1). Calling BFS to find the
    true cost to goal is exponential.</p>

    <p>You want a heuristic which reduces total compute time, though for this assignment
    the autograder will only check node counts (aside from enforcing a reasonable time
    limit).</p>

    <h3>Part 3 Feedback</h3>

    <p>Give one short piece of feedback about the course so far. What have you found most
    interesting? Is there a topic that you had trouble understanding? Are there any
    changes that could improve the value of the course to you?</p>

    <p>How many hours did you spend on this assignment?</p>

    <p>Please provide your answers in search.py.</p>

    <p>This assignment builds upon work by Maxwell Libbrecht and was adapted from the Pacman AI projects developed at UC Berkeley.<br />
    <a href="http://ai.berkeley.edu/project_overview.html">http://ai.berkeley.edu/project_overview.html</a></p>
  
</p></div>

      </div><!-- /.entry-contentProject -->
    </div><!-- /.entry-wrapper -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo" class="entry-wrapper">
    

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
<span>&copy; 2021 Yagiz Aksoy</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script type="text/javascript">
  var BASE_URL = 'http://yaksoy.github.io';
</script>

<!-- Include Latex style math -->
<!-- https://stackoverflow.com/questions/10987992/using-mathjax-with-jekyll -->
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://yaksoy.github.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://yaksoy.github.io/assets/js/scripts.min.js"></script>



<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11195487; 
var sc_invisible=1; 
var sc_security="112d9b46"; 
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="shopify
analytics" href="http://statcounter.com/shopify/"
target="_blank"><img class="statcounter"
src="//c.statcounter.com/11195487/0/112d9b46/1/"
alt="shopify analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->

</body>
</html>
